import type { ConfigurationParameters, Status, TextMatchingStrategy } from '@ipfs-shipyard/pinning-service-client';
import type { Libp2p } from '@libp2p/interface';
import type { AbortOptions, Multiaddr } from '@multiformats/multiaddr';
import type { AddOptions, HeliaLibp2p, IsPinnedOptions, LsOptions, Pin, Pins } from 'helia';
import type { CID } from 'multiformats/cid';
/**
 * A function that takes and returns a list of multiaddrs
 */
export interface MulitaddrFilter {
    (origins: Multiaddr[]): Multiaddr[];
}
export interface HeliaRemotePinnerInit extends ConfigurationParameters {
    /**
     * A function to filter the origins that the pinning provider can use to
     * retrieve the content.
     *
     * You can use this to filter out multiaddrs that aren't dialable by the
     * pinning provider.
     *
     * @default (origins) => origins
     */
    originFilter?: MulitaddrFilter;
    /**
     * A function to filter the delegates that the pinning provider expects us to
     * connect to, before we connect to them.
     *
     * @default (delegates) => delegates
     */
    delegateFilter?: MulitaddrFilter;
    /**
     * When adding a pin we poll the pinning service for status updates. This
     * setting controls how often that polling occurs in ms.
     *
     * @default 1000
     */
    pollInterval?: number;
}
/**
 * Allows passing extra options accepted by the remote pinning service
 */
export interface RemoteAddOptions extends Omit<AddOptions, 'metadata'> {
    name?: string;
    metadata?: Record<string, string>;
}
/**
 * Allows passing extra options accepted by the remote pinning service
 */
export interface RemoteLsOptions extends LsOptions {
    name?: string;
    match?: TextMatchingStrategy;
    status?: Status[];
    before?: Date;
    after?: Date;
}
/**
 * Includes extra metadata supported by the remote pinning service
 */
export interface RemotePin extends Pin {
    name?: string;
    status: Status;
}
export interface RemoteIsPinnedOptions extends IsPinnedOptions {
}
/**
 * Extends the Pins interface with remote pinning-specific arguments and return
 * types (e.g. metadata as `Record<string, string>` and pins with an added
 * `.status` property)
 */
export interface RemotePins extends Pins {
    /**
     * Pin a block in the blockstore. It will not be deleted
     * when garbage collection is run.
     */
    add(cid: CID, options?: RemoteAddOptions): AsyncGenerator<CID, void, undefined>;
    /**
     * List all blocks that have been pinned.
     */
    ls(options?: RemoteLsOptions): AsyncGenerator<RemotePin, void, undefined>;
    /**
     * Return true if the passed CID is pinned
     */
    isPinned(cid: CID, options?: RemoteIsPinnedOptions): Promise<boolean>;
    /**
     * Return pin details
     */
    get(cid: CID, options?: AbortOptions): Promise<RemotePin>;
    /**
     * Update pin metadata
     */
    setMetadata(cid: CID, metadata: Record<string, string> | undefined, options?: AbortOptions): Promise<void>;
}
export type HeliaWithRemotePins<T extends Libp2p = Libp2p> = Omit<HeliaLibp2p<T>, 'pins'> & {
    pins: RemotePins;
};
/**
 * Create a remote pins instance powered by the passed Helia node
 */
export declare function createRemotePins<T extends Libp2p = Libp2p>(helia: HeliaLibp2p<T>, init?: HeliaRemotePinnerInit): RemotePins;
/**
 * Patches the passed Helia node with the remote pins instance, this function
 * makes dealing with the types a little easier
 */
export declare function heliaWithRemotePins<T extends Libp2p = Libp2p>(helia: HeliaLibp2p<T>, init?: HeliaRemotePinnerInit): HeliaWithRemotePins<T>;
//# sourceMappingURL=index.d.ts.map